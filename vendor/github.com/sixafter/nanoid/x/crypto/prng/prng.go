// Copyright (c) 2024 Six After, Inc
//
// This source code is licensed under the Apache 2.0 License found in the
// LICENSE file in the root directory of this source tree.

// Package prng provides a cryptographically secure pseudo-random number generator (PRNG)
// that implements the io.Reader interface. It is designed for high-performance, concurrent
// use in generating random bytes.
//
// This package is part of the experimental "x" modules and may be subject to change.

package prng

import (
	"crypto/rand"
	"fmt"
	"io"
	"sync"

	"golang.org/x/crypto/chacha20"
)

// Reader is a global io.Reader that manages a pool of prng instances internally.
// It allows concurrent reads without exposing pool management to the user.
//
// Example usage:
//
//	buffer := make([]byte, 64)
//	n, err := Reader.Read(buffer)
//	if err != nil {
//	    // Handle error
//	}
//	fmt.Printf("Read %d bytes of random data: %x\n", n, buffer)
var Reader io.Reader = &poolReader{}

// poolReader is a custom io.Reader that uses a sync.Pool to manage prng instances.
type poolReader struct{}

// NewReader returns a new instance that implements the io.Reader interface.
// This instance can be used for cryptographically secure, pseudo-random byte generation.
//
// Example usage:
//
//	reader, err := NewReader()
//	if err != nil {
//	    // Handle error
//	}
//
//	buffer := make([]byte, 64)
//	n, err := reader.Read(buffer)
//	if err != nil {
//	    // Handle error
//	}
//	fmt.Printf("Read %d bytes of random data: %x\n", n, buffer)
func NewReader() (io.Reader, error) {
	return &poolReader{}, nil
}

// Read fills the provided byte slice 'b' with random data generated by a prng instance from the pool.
// It acquires a prng from the pool, performs the read, and returns the prng to the pool.
// If the prng instance is an errorPRNG, it returns the associated error.
//
// This method allows for efficient reuse of PRNG instances, reducing contention on crypto/rand.Reader.
//
// Example usage:
//
//	buffer := make([]byte, 32)
//	n, err := Reader.Read(buffer)
//	if err != nil {
//	    // Handle error
//	}
//	fmt.Printf("Read %d bytes of random data: %x\n", n, buffer)
func (r *poolReader) Read(b []byte) (int, error) {
	p := prngPool.Get().(io.Reader)
	defer prngPool.Put(p)
	return p.Read(b)
}

// prng represents a cryptographically secure pseudo-random number generator that implements io.Reader.
// It utilizes the ChaCha20 cipher stream to generate random bytes.
//
// Each prng instance is initialized with a unique key and nonce sourced from crypto/rand.Reader.
type prng struct {
	stream *chacha20.Cipher
	zero   []byte
}

// errorPRNG is a special prng that always returns an error on Read.
// It is used to signify a failure in prng initialization.
//
// This struct implements the io.Reader interface, but its Read method always fails.
type errorPRNG struct {
	err error
}

// Read implements the io.Reader interface for errorPRNG.
// It always returns an error, indicating prng initialization failure.
//
// This method ensures that any read operation using an errorPRNG instance fails gracefully.
func (e *errorPRNG) Read(_ []byte) (int, error) {
	return 0, e.err
}

// newPRNG initializes and returns a new prng instance.
// It reads a unique key and nonce from crypto/rand.Reader to seed the ChaCha20 cipher.
//
// Returns an error if key or nonce generation fails, or if the cipher cannot be created.
func newPRNG() (*prng, error) {
	// ChaCha20 key is 32 bytes (256 bits)
	key := make([]byte, chacha20.KeySize)
	// ChaCha20 nonce is 12 bytes
	nonce := make([]byte, chacha20.NonceSizeX)

	// Read key and nonce from crypto/rand.Reader
	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		return nil, fmt.Errorf("prng.newPRNG: failed to read key from crypto/rand.Reader: %w", err)
	}
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, fmt.Errorf("prng.newPRNG: failed to read nonce from crypto/rand.Reader: %w", err)
	}

	// Create a new ChaCha20 cipher stream
	cipher, err := chacha20.NewUnauthenticatedCipher(key, nonce)
	if err != nil {
		return nil, fmt.Errorf("prng.newPRNG: failed to create ChaCha20 cipher: %w", err)
	}

	return &prng{
		stream: cipher,
		zero:   make([]byte, 0), // Initialize an empty slice
	}, nil
}

// Read fills the provided byte slice 'b' with random data generated by the prng.
// It implements the io.Reader interface.
//
// This method is safe for exclusive use by a single goroutine.
//
// It generates random bytes by encrypting zero bytes using the ChaCha20 cipher stream.
func (p *prng) Read(b []byte) (int, error) {
	// Reuse the zero buffer if it's large enough
	if cap(p.zero) < len(b) {
		p.zero = make([]byte, len(b))
	} else {
		p.zero = p.zero[:len(b)]
		// No need to reset to zero since 'make' initializes it to zero
	}

	// Generate random bytes by encrypting zero bytes
	p.stream.XORKeyStream(b, p.zero)
	return len(b), nil
}

// prngPool is a sync.Pool that holds prng instances to reduce contention on crypto/rand.Reader.
// It allows multiple goroutines to acquire separate prng instances for concurrent random byte generation.
//
// Each prng instance is either a valid prng or an errorPRNG if initialization failed.
var prngPool = sync.Pool{
	New: func() interface{} {
		p, err := newPRNG()
		if err != nil {
			// Instead of panicking, return an errorPRNG instance with the error.
			return &errorPRNG{err: fmt.Errorf("prngPool.New: failed to create prng: %v", err)}
		}
		return p
	},
}
